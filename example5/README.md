# 目标

- 完成动态协议解析

# 包介绍

| 包名             | 作用                                             |
|----------------|------------------------------------------------|
| cbim           | 主程序<br/> - spring boot 编写                      |
| flow           | 责任链模块<br/> - 各种工厂方法<br/> - 各种模块类<br/> - 初始化责任链 |
| flow-base      | 责任链基础包<br/> - 责任链方法<br/> - 责任链类对象              |
| source-base    | 基础包<br/> - 用于存储各种公有变量                          |
| source-tool    | 工具包<br/> - 本次主要实现从 IOC 中拿 bean 对象              |
| souce-netty    | 使用 netty 做的采集包                                 |
| source-analyse | 动态协议中的解析模块                                     |

# 地位

在该项目中我认为有几个非常重要的核心，如

- 责任链的执行
- 责任链中 `DataInit` 和 `EventInit` 使业务和架构分离
- 动态协议解析

# 什么是动态协议解析

想象一下这种场景，有两个设备进行通信，通信之间的协议是双方协商好了，比如

- 第一个字节到第八个字节是姓名
- 第 `100` 个字节是 性别
- ...

如果，协议不变还好说，如果有另外一个设备接进来，协议如下

- 第 `10` 个字节到 `18` 个字节是姓名
- ...

这样的话，每次接入的设备协议都不一样，如果，每次新来一个设备就要重新编写解析代码，无疑增加了巨量的工作量。

那么，有没有一种方法，可以动态的配置相关协议呢？

这就是本章节，动态协议解析要做的事情。

动态协议解析共分为三步。

- 切包
- 解析
- 组合

## 切包

比如，个人的账户信息是放在一起的，详情如下

- 第 `10` 字节到 `18` 字节是姓名
- 第 `19` 字节到 `20` 字节是性别
- 第 `21` 字节到 `40` 字节是籍贯

那么，该个人信息可以进行下面的配置

```
- {key: 2,offset: 10,size: 31,tipZh: 个人信息}
```

当数据来到时，比如，数据长度是 `1000` 字节，那么，切包流程就会把 `10 - 40` 字节，切出来，放到一个 `map` 中。

## 解析

上面将包切出来之后，就要进行解析了，表明该字节数组代表什么数据。

```
- type: 1
  content:
    - { order: 0,fieldName: name,placeholder: 9,hexString: 3,endian: little,tipZh: 姓名 }
    - { order: 0,fieldName: sex,placeholder: 2,hexString: 3,endian: little,tipZh: 性别 }
    - { order: 0,fieldName: home,placeholder: 10,hexString: 3,endian: little,tipZh: 籍贯 }
```

当切包数据来到解析模块后，就会根据解析配置，将数据进行一一解析，放到一个 `map` 中

## 组包

组包是根据服务来的。比如，一个服务中需要的数据有个人信息，学校信息等，可以根据实际服务所需数据，进行组包。

然后把组包的数据传递到对应的服务上。

# 协议构建

- `ef ef ef ef` 【`4` 字节的开头】
- `13` 字节的名字
- `6` 字节的性别
- `4` 字节的年龄
- `8` 字节预留
- `15` 字节的成绩
    - 每科成绩占 `3` 字节，分别是 语数英
- `8` 字节预留
- `ef ef ef ef` 【`4` 字节结尾】

# 数据

- `E5 B0 8F E6 98 8E 00 00 00 00 00 00`
  - 小明
- `E7 94 B7 00 00 00`
  - 男
- `31 32 00 00`
  - `12`
- `01 d5 3b`      
  - `120123`
- `00 00 00 00 00 00 00 00`

使用网络助手发送数据如下

```
- 00 00 00 3D Ef EF Ef EF E5 B0 8F E6 98 8E 00 00 00 00 00 00 E7 94 B7 00 00 00 31 32 00 00 00 00 00 00 00 00 00 00 01 d5 3b 01 d5 3a 01 d5 3c 01 d5 3a 00 00 75 00 00 00 00 00 00 00 00 EF EF Ef EF
```

相关的 `netty` 的切包配置请自己查看。

运行该模块的正确输出是

```
[main] INFO  com.cbim.flow.factory.CombineFactory - {name:小明},{scoreList:[{score:121359}, {score:121358}, {score:121360}, {score:121358}, {score:117}]}
```
